# Лабораторная работа №7. Создание многоконтейнерного приложения

## Студент

**Славов Константин, группа I2302**  
**Дата выполнения: _07.04.2025_**

## Цель работы

Данная лабораторная работа призвана ознакомить студента с работой многоконтейнерного приложения на базе `docker-compose`.

## Задание

Создать **PHP** приложение на базе трех контейнеров: **nginx**, **php-fpm**, **mariadb**, используя `docker-compose`.

## Ход работы

**1. Создал репозиторий `containers07` и склонировал его к себе на компьютер.**

![image](https://i.imgur.com/PLOaxvz.jpeg)

**2. В директории `containers07` я создал директорию `mounts/site`. В данную директорию переписал сайт на PHP, созданный в рамках предмета по PHP.**

В качестве сайта я взял образец, выполненный по заданию Лабораторной работы №3 по предмету **PHP**.

![image](https://i.imgur.com/R2Lv1s8.jpeg)

**3. Создал файл `.gitignore` в корне проекта и добавил в него строки:**

```gitignore
# Ignore files and directories
mounts/site/*
```

![image](https://i.imgur.com/kEPcs4j.jpeg)

**4. Создал в директории `containers07` файл `nginx/default.conf` со следующим содержимым:**

```nginx
server {
    listen 80;
    server_name _;
    root /var/www/html;
    index index.php;
    location / {
        try_files $uri $uri/ /index.php?$args;
    }
    location ~ \.php$ {
        fastcgi_pass backend:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
```

Этот блок описывает настройки веб-сервера. Директива `listen 80;` указывает серверу слушать HTTP-порт 80. `server_name _;` означает, что сервер будет обрабатывать все запросы, независимо от имени хоста. `root /var/www/html;` указывает, где расположены файлы сайта внутри контейнера. `index index.php;` задаёт файл, который будет загружаться по умолчанию.
Блок `location /` отвечает за обработку корневого пути и пробует найти файл или папку, иначе перенаправляет запрос на `index.php`. Блок `location ~ \.php$` обрабатывает PHP-файлы: отправляет их на обработку в **PHP-FPM**, указывает путь к исполняемому файлу и включает стандартные параметры **FastCGI**.

**5. Создайте в директории `containers07` файл `docker-compose.yml` со следующим содержимым:**

```yaml
version: '3.9'

services:
  frontend:
    image: nginx:1.19
    volumes:
      - ./mounts/site:/var/www/html
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf
    ports:
      - "80:80"
    networks:
      - internal
  backend:
    image: php:7.4-fpm
    volumes:
      - ./mounts/site:/var/www/html
    networks:
      - internal
    env_file:
      - mysql.env
  database:
    image: mysql:8.0
    env_file:
      - mysql.env
    networks:
      - internal
    volumes:
      - db_data:/var/lib/mysql

networks:
  internal: {}

volumes:
  db_data: {}
```

Этот файл `docker-compose.yml` описывает инфраструктуру из трёх взаимосвязанных сервисов: frontend, backend и база данных. Он использует синтаксис версии 3.9 Docker Compose. В качестве frontend-сервера используется образ `nginx:1.19`, который подключает локальную директорию `./mounts/site` как корневую директорию сайта (`/var/www/html`) и применяет конфигурационный файл nginx из `./nginx/default.conf`. Этот сервис пробрасывает порт 80, чтобы сайт был доступен из браузера, и подключается к внутренней сети `internal`.

Backend-сервис работает на основе образа `php:7.4-fpm` и также использует директорию `./mounts/site` для доступа к исходному коду. Он подключён к той же внутренней сети и получает переменные окружения из файла `mysql.env`, что позволяет настроить, например, подключение к базе данных.

Третий сервис — это база данных, использующая образ `mysql:8.0`. Она тоже загружает настройки из файла `mysql.env`, такие как имя пользователя, пароль и имя базы данных. Все её данные сохраняются в постоянном томе `db_data`, чтобы не терялись при перезапуске контейнера. Все три сервиса находятся внутри общей виртуальной сети `internal`, благодаря чему могут безопасно взаимодействовать между собой без внешнего доступа.

![image](https://i.imgur.com/2nYrJin.jpeg)

**6. Создал файл `mysql.env` в корне проекта и добавил в него строки:**

```env
MYSQL_ROOT_PASSWORD=secret
MYSQL_DATABASE=app
MYSQL_USER=user
MYSQL_PASSWORD=secret
```

Этот блок с переменными окружения используется для настройки контейнера MySQL.  

`MYSQL_ROOT_PASSWORD=secret` задаёт пароль для root-пользователя MySQL.  
`MYSQL_DATABASE=app` указывает, что при запуске будет автоматически создана база данных с именем `app`.  
`MYSQL_USER=user` и `MYSQL_PASSWORD=secret` создают дополнительного пользователя `user` с паролем `secret`, который получает доступ к базе `app`.

Эти переменные передаются контейнеру через файл `mysql.env` и позволяют автоматически настроить базу данных при первом запуске.

## Запуск и тестирование

**1. Запустил контейнеры командой:**

```bash
docker-compose up -d
```

Команда `docker-compose up -d` используется для запуска всех сервисов, описанных в файле `docker-compose.yml`, в фоновом режиме. При её выполнении Docker Compose считывает конфигурацию, создаёт необходимые сети и тома, загружает или пересобирает образы, если это необходимо, и запускает контейнеры для каждого сервиса. Все тома и переменные окружения подключаются автоматически, как указано в файле. Благодаря флагу `-d` (detached mode), все контейнеры запускаются в фоне, и терминал остаётся свободным для дальнейших команд. После выполнения этой команды приложение начинает работать и становится доступным, например, по адресу `http://localhost`, если для веб-сервера проброшен порт.

![image](https://i.imgur.com/dsXDdXk.jpeg)

**2. Проверил работу сайта в браузере, ввел в адресную строку `https://localhost`**

Для выполнения этого шага, я ввел данный адрес в браузер и получил работающий сайт со всем функционалом, который должен быть:

![image](https://i.imgur.com/kVZ2UD5.jpeg)

## Ответы на вопросы

**1. В каком порядке запускаются контейнеры?**

Контейнеры в Docker Compose запускаются параллельно, без гарантированного порядка. Однако если один контейнер зависит от другого (например, backend от базы данных), рекомендуется использовать опцию `depends_on`, чтобы задать порядок запуска. Даже с этой опцией Docker не дожидается готовности зависимого сервиса — он просто запускает его раньше. Поэтому для реальной зависимости по состоянию нужно использовать дополнительные механизмы ожидания, например, `wait-for-it` или `healthcheck`.

**2. Где хранятся данные базы данных?**

Данные MySQL хранятся в постоянном томе, указанном в секции `volumes`. В данном случае используется именованный том `db_data`, который монтируется в контейнер по пути `/var/lib/mysql`. Это значит, что даже после остановки или пересоздания контейнера база данных сохранит своё содержимое.

**3. Как называются контейнеры проекта?**

По умолчанию Docker Compose формирует имена контейнеров в формате: `<имя_папки>-<имя_сервиса>-1`.

Например, если проект находится в папке containers07, то контейнеры будут называться:

- containers07-frontend-1
- containers07-backend-1
- containers07-database-1

Эти имена можно изменить явно, указав параметр `container_name` в описании сервиса.

**4. Вам необходимо добавить еще один файл `app.env` с переменной окружения `APP_VERSION` для сервисов `backend` и `frontend`. Как это сделать?**

Для этого нужно создать файл `app.env` в корне проекта и записать туда строку:

```env
APP_VERSION=1.0.0
```

Затем в файле `docker-compose.yml` добавить в оба сервиса (`frontend` и `backend`) строку:

```yaml
env_file:
  - mysql.env
  - app.env
```

В итоге сервисы будут загружать переменные окружения из обоих файлов — `mysql.env` и `app.env`.

## Выводы

В процессе выполнения лабораторной работы, я научился разворачивать многоконтейнерное приложение с помощью Docker Compose. Мне удалось настроить три контейнера: nginx в качестве веб-сервера, PHP-FPM как обработчик PHP-кода и MySQL в роли базы данных. Я использовал свой сайт, сделанный ранее, и подключил его к инфраструктуре, монтируя код в нужные директории контейнеров. Через конфигурационный файл nginx я настроил маршрутизацию и обработку PHP-запросов. Отдельно создал файл `mysql.env`, с помощью которого автоматически настроил базу данных и пользователя при запуске. Также я добавил дополнительный файл `app.env` и подключил его к нужным сервисам, чтобы передать переменную окружения. Все контейнеры связаны между собой внутренней сетью и при запуске работают как единое целое. Запуск прошёл успешно, сайт открылся через браузер, и всё работало корректно. Благодаря этой работе я понял, как легко управлять несколькими сервисами с помощью одного `docker-compose.yml`, и насколько удобно собирать полноценную среду для разработки с помощью контейнеров.

## Библиография

- [Официальная документация Docker Compose](https://docs.docker.com/compose/) - Источник, описывающий синтаксис `docker-compose.yml`, принципы работы с многоконтейнерными приложениями, команды для запуска, настройки томов, сетей и переменных окружения. Используется как основа для понимания структуры проекта.
- [Docker Hub — образ nginx](https://hub.docker.com/_/nginx) - Страница содержит официальные описания Docker-образов на базе **nginx**, доступные теги версий, переменные окружения, порты и инструкции по использованию.
- [Docker Hub — образ php](https://hub.docker.com/_/php) - Страница содержит официальные описания Docker-образов на базе **PHP**, доступные теги версий, переменные окружения, порты и инструкции по использованию.
- [Docker Hub — образ mysql](https://hub.docker.com/_/mysql) - Страница содержит официальные описания Docker-образов на базе **mySQL**, доступные теги версий, переменные окружения, порты и инструкции по использованию.
- [Официальная документация по env_file и переменным окружения в Compose](https://docs.docker.com/compose/environment-variables/) - Описывает способы задания переменных окружения для сервисов: напрямую, через `.env`, `env_file` и через командную строку. Использовалась при подключении файлов `mysql.env` и `app.env`.
- [Docker Volume и хранение данных](https://docs.docker.com/storage/volumes/) - Подробное объяснение, как работают тома в Docker, зачем они нужны и как позволяют сохранять данные между перезапусками контейнеров. Это важно для настройки и понимания `db_data`.
- [Официальная документация PHP-FPM](https://www.php.net/manual/ru/install.fpm.php) - Описывает особенности **PHP-FPM**, его конфигурацию и работу как отдельного процесса, к которому nginx обращается по FastCGI. Полезно для понимания backend-контейнера.